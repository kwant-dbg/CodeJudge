# CodeJudge Azure Deployment Plan (Container Apps)

This plan describes how to deploy CodeJudge to Azure using Azure Container Apps (ACA), with managed PostgreSQL, Azure Cache for Redis, Azure Container Registry (ACR), an Azure Storage File share for submission artifacts, and centralized logging with Log Analytics. It’s optimized for simplicity and student budgets while supporting production hardening.

## Project overview

- Services (containers)
  - API Gateway (Go) – port 8080, reverse-proxy to internal services
  - Problems Service (Go) – port 8000, DB access
  - Submissions Service (Go) – port 8001, DB + Redis, shared submissions volume
  - Plagiarism Service (Go) – port 8002, DB + Redis
  - Judge Service (C++) – worker consuming Redis queue, DB access, shared submissions volume
- Datastores
  - PostgreSQL (Flexible Server)
  - Redis Cache
- Shared storage
  - Azure Files share mounted into Submissions and Judge
- Images built from Dockerfiles in repo; recommended hosting in ACR
- Health endpoints present on services (API gateway exposes /health and /ready)

## Azure target architecture

- Azure Container Apps Environment (ACA Env) hosting 5 container apps
  - Ingress: API Gateway external HTTP on port 8080 (public)
  - Problems/Submissions/Plagiarism/Judge: internal-only (no external ingress)
  - Internal service-to-service via container apps environment DNS
- Azure Container Registry (ACR) for images and automated pulls
- Azure Database for PostgreSQL Flexible Server (Basic/Burstable)
- Azure Cache for Redis (Basic C0)
- Storage Account (Standard LRS) with a File Share for submissions
- Log Analytics Workspace wired to ACA Env for logs/metrics
- Optional: Key Vault for connection strings/secrets (can start with ACA secrets)

### Mermaid architecture

```mermaid
flowchart LR
  User((User)) -->|HTTPS :8080| APIGW[API Gateway (ACA, external ingress)]
  subgraph ACA[Azure Container Apps Environment]
    APIGW --> PROB[Problems Service (internal)]
    APIGW --> SUBM[Submissions Service (internal)]
    APIGW --> PLAG[Plagiarism Service (internal)]
    SUBM -->|enqueue/dequeue| REDIS[(Azure Cache for Redis)]
    JUDG[Judge Service (worker, internal)] -->|BLPOP| REDIS
    SUBM --- FILES[(Azure Files Share)]
    JUDG --- FILES
  end
  PROB -->|psql| PG[(Azure PostgreSQL Flexible Server)]
  SUBM -->|psql| PG
  PLAG -->|psql| PG
  JUDG -->|psql| PG
  APIGW -. pulls .- ACR[(Azure Container Registry)]
  PROB  -. pulls .- ACR
  SUBM  -. pulls .- ACR
  PLAG  -. pulls .- ACR
  JUDG  -. pulls .- ACR
  ACA --- LAW[(Log Analytics Workspace)]
```

## Container Apps configuration

- Resource sizing (initial):
  - API Gateway: 0.5 vCPU, 1.0 Gi RAM, minReplicas 1, maxReplicas 2
  - Problems: 0.5 vCPU, 1.0 Gi RAM, minReplicas 1, maxReplicas 2
  - Submissions: 0.5 vCPU, 1.0–2.0 Gi RAM, minReplicas 1, maxReplicas 2
  - Plagiarism: 0.5 vCPU, 1.0 Gi RAM, minReplicas 0–1, maxReplicas 2
  - Judge: 1–2 vCPU, 2.0 Gi RAM, minReplicas 0–1, maxReplicas 2 (CPU/mem heavier)
- Ingress:
  - API Gateway: external HTTP on 8080
  - Others: no external ingress (internal only)
- Scaling: simple CPU-based autoscale to start; can add KEDA-based scale on Redis queue later
- Volumes (Azure Files):
  - Create storage account + file share (e.g., cjsubmissions)
  - Mount to Submissions and Judge at /app/submissions

## Environment variables and secrets

- DATABASE_URL: postgresql://USER:PASSWORD@HOST:5432/DBNAME?sslmode=require
- REDIS_URL: rediss://HOST:6380 (Redis TLS). If auth is needed, include username/password as per Redis config
- SUBMISSION_STORAGE_PATH: /app/submissions (for Submissions)
- SUBMISSION_WORKDIR: /app/submissions (for Judge)
- API Gateway service URLs (use ACA internal FQDNs once created):
  - PROBLEMS_SERVICE_URL
  - SUBMISSIONS_SERVICE_URL
  - PLAGIARISM_SERVICE_URL

Notes
- Use ACA secrets for database and redis credentials (or Key Vault). Reference secrets in env vars.
- Ensure Redis TLS (rediss://) and Postgres sslmode=require.

## Recommended Azure resources (initial)

- Azure Container Registry: Basic tier
- Azure Container Apps Environment: Consumption plan
- Azure Database for PostgreSQL Flexible Server: Burstable (B1/B2), zone redundant off
- Azure Cache for Redis: Basic C0
- Storage Account: Standard_LRS; File share quota 10–50 GB
- Log Analytics Workspace

## Execution steps (PowerShell-friendly)

Prerequisites
- Azure CLI and Azure Developer CLI (azd) installed
- Docker installed and signed in
- Azure subscription access

High-level
1) Provision resource group, ACR, Log Analytics, ACA Environment, Storage (File share), PostgreSQL, Redis
2) Build and push images to ACR
3) Create Container Apps for each service with the right env and mounts
4) Validate health and endpoints

Details (indicative)
1) Provision (IaC strongly recommended; manual CLI alternative ok to start)
   - Create resource group (e.g., rg-codejudge)
   - Create ACR (e.g., cjregistry)
   - Create Log Analytics workspace
   - Create Container Apps Environment (link to workspace)
   - Create Storage Account + File share (e.g., cjsubmissions)
   - Create PostgreSQL Flexible Server and database; create user/password; enforce TLS
   - Create Azure Cache for Redis; enable TLS (default); capture hostname and key
   - Create a user-assigned managed identity for container apps; grant AcrPull on ACR
   - Store sensitive values as ACA secrets (or Key Vault) for later reference by apps

2) Build and push images (ACR)
   - For each service (api-gateway, problems, submissions, plagiarism, judge):
     - docker build -t <ACR>.azurecr.io/codejudge/<svc>:<tag> -f <Dockerfile> <context>
     - docker push <ACR>.azurecr.io/codejudge/<svc>:<tag>

3) Create Container Apps
   - API Gateway (external ingress 8080)
     - Env vars:
       - PROBLEMS_SERVICE_URL=http://problems.<internalFQDN>:8000
       - SUBMISSIONS_SERVICE_URL=http://submissions.<internalFQDN>:8001
       - PLAGIARISM_SERVICE_URL=http://plagiarism.<internalFQDN>:8002
   - Problems (internal-only)
     - Env vars: DATABASE_URL
   - Submissions (internal-only)
     - Env vars: DATABASE_URL, REDIS_URL, SUBMISSION_STORAGE_PATH=/app/submissions
     - Volume: Azure File share mounted at /app/submissions
   - Plagiarism (internal-only)
     - Env vars: DATABASE_URL, REDIS_URL
   - Judge (internal-only; no ingress)
     - Env vars: DATABASE_URL, REDIS_URL, SUBMISSION_WORKDIR=/app/submissions
     - Volume: Azure File share mounted at /app/submissions

4) Validate
   - Check container app revisions healthy; logs in Log Analytics
   - Call API Gateway /health and /ready
   - Create a sample problem, submission; confirm judging pipeline moves via Redis

## Notes & options

- Alternative hosting: Azure Kubernetes Service (AKS) provides full control but requires more ops; manifests for two services exist and would need to be completed for all.
- Alternative to ACR: You can use GHCR images, but you’ll need to configure registry credentials for Container Apps; ACR is simpler.
- Scaling: Add KEDA-based rules on Redis queue length later; start with CPU-based autoscale.
- Secrets: Start with ACA secrets and migrate to Key Vault when ready.

## Next actions

- Use this plan to generate IaC (Bicep) in infra/ and an azure.yaml for azd deployments. Then run `azd provision --preview` followed by `azd up` to provision and deploy.
- If you prefer a manual first run, follow the execution outline above with Azure CLI and then iterate toward IaC.
